{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#gades-gentlest-ascent-dynamics-for-enhanced-sampling","title":"GADES: Gentlest Ascent Dynamics for Enhanced Sampling","text":"<p>GADES is an enhanced sampling method based on Gentlest Ascent Dynamics (GAD) for exploring molecular configuration space without prior knowledge of reaction coordinates.</p>"},{"location":"#installation","title":"Installation","text":"<p>to install, clone the repository</p> <pre><code>git clone https://github.com/arminshzd/GADES.git\n</code></pre> <p>create a conda environment <code>(python &gt;= 3.10)</code></p> <pre><code>conda create -n GADES python=3.10 \nconda activate GADES\n</code></pre> <p>and install from inside the <code>GADES</code> directory using <code>pip</code></p> <pre><code>pip install -e .\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/AIB9/","title":"AIB9","text":""},{"location":"examples/MB_pot/","title":"M\u00fcller-Brown 2D Potential","text":""},{"location":"examples/sulf/","title":"Sulfadiazine","text":""},{"location":"reference/GADES/","title":"<code>GADES.py</code> API reference","text":""},{"location":"reference/GADES/#GADES.GADESForceUpdater","title":"GADESForceUpdater","text":"<pre><code>GADESForceUpdater(biased_force, bias_atom_indices, hess_func, clamp_magnitude, kappa, interval, stability_interval=None, logfile_prefix=None)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Initialize a GADESForceUpdater for applying Gentlest Ascent Dynamics (GADES) bias forces.</p> <p>The updater identifies the softest Hessian eigenmode of the system and constructs a directional bias force along that mode using: $$ F_{\\text{GADES}} = - \\kappa \\, (\\mathbf{F}_{\\text{system}} \\cdot \\vec{n}) \\, \\vec{n}, $$</p> <p>where \\(\\vec{n}\\) is normalized eigenvector corresponding to the softest mode. the The bias is applied to a specified set of atoms at regular intervals, with optional stability checks and logging.</p> <p>Parameters:</p> Name Type Description Default <code>biased_force</code> <code>CustomExternalForce</code> <p>The OpenMM force object that will receive GADES bias forces. Must be created using <code>getGADESBiasForce()</code>.</p> required <code>bias_atom_indices</code> <code>Sequence[int]</code> <p>Indices of atoms that should receive the bias force.</p> required <code>hess_func</code> <code>Callable</code> <p>A user-supplied function returning the Hessian matrix for the system. Must accept <code>(system, positions, atom_indices, step_size, platform)</code> as input and return a 2D array-like Hessian. Choose one of  <code>GADES.utils.compute_hessian_force_fd_richardson</code>,  <code>GADES.utils.compute_hessian_force_fd_block_serial</code>, or <code>GADES.utils.compute_hessian_force_fd_block_parallel</code>. We suggest the Richardson variant.</p> required <code>clamp_magnitude</code> <code>float</code> <p>Maximum allowed magnitude for each component of the bias force, used to prevent unphysical updates or exploration of irrelavant regions.</p> required <code>kappa</code> <code>float</code> <p>Scaling factor (0 &lt; \u03ba &lt; 1) applied to the bias force along the softest eigenmode. GADES is designed for exploration applications with \u03ba=0.9. Values larger than 1 will lead to the system lingering in the transition regions. Values smaller than 0.9 limit the maximum gradient GADES is able to overcome. We suggest controling this with <code>clamp_magnitude</code> instead of <code>kappa</code> since <code>kappa</code> will damp all forces while the clamp is only effective in high- gradient regions.</p> required <code>interval</code> <code>int</code> <p>Number of simulation steps between bias force updates. Values less than 100 are overridden to 110 internally to ensure stability. Smaller values make for a more accurate bias direction, at the  expense of computational cost. In our experience, a value of  ~2000 is a good place to start.</p> required <code>stability_interval</code> <code>int</code> <p>Number of steps between stability checks based on kinetic temperature. If None, only post-bias stability checks are used. This check ensures that the system doesn't stray too far from  the set temperature by turning the bias off if the temperature rises &gt;50 K of the simulation temeprature. We suggest a value of 500 steps for most simulations.</p> <code>None</code> <code>logfile_prefix</code> <code>str</code> <p>Prefix for log files. If provided, the following files are created:   - <code>&lt;prefix&gt;_evec.log</code>: trajectory of softest-mode eigenvectors   - <code>&lt;prefix&gt;_eval.log</code>: trajectory of  sorted eigenvalue spectra   - <code>&lt;prefix&gt;_biased_atoms.xyz</code>: biased atom trajectories in XYZ format</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>interval</code> is not a positive integer.</p> <code>OSError</code> <p>If log files cannot be created when <code>logfile_prefix</code> is set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from GADES import getGADESBiasForce, GADESForceUpdater\n&gt;&gt;&gt; from GADES.utils import compute_hessian_force_fd_richardson as hessian\n&gt;&gt;&gt; system = ...\n&gt;&gt;&gt; simulation = ...\n&gt;&gt;&gt; biasing_atom_ids = ...\n&gt;&gt;&gt; GAD_force = getGADESBiasForce(system.getNumParticles())\n&gt;&gt;&gt; GADESupdater = GADESForceUpdater(\n                    biased_force=GAD_force, \n                    bias_atom_indices=biasing_atom_ids,\n                    hess_func=hessian, \n                    clamp_magnitude=2500,\n                    kappa=0.9, \n                    interval=1000, \n                    stability_interval=500, \n                    logfile_prefix=\"GADES_log\"\n                    )\n&gt;&gt;&gt; simulation.reporters.append(GADESupdater)\n&gt;&gt;&gt; simulation.step(10000)\n</code></pre> Source code in <code>GADES/gades.py</code> <pre><code>def __init__(\n    self,\n    biased_force: CustomExternalForce,\n    bias_atom_indices: Sequence[int],\n    hess_func: Callable,\n    clamp_magnitude: float,\n    kappa: float,\n    interval: int,\n    stability_interval: Optional[int] = None,\n    logfile_prefix: Optional[str] = None,\n):\n    r\"\"\"\n    Initialize a GADESForceUpdater for applying Gentlest Ascent Dynamics (GADES) bias forces.\n\n    The updater identifies the softest Hessian eigenmode of the system and constructs\n    a directional bias force along that mode using:\n    $$\n    F_{\\text{GADES}} = - \\kappa \\, (\\mathbf{F}_{\\text{system}} \\cdot \\vec{n}) \\, \\vec{n},\n    $$\n\n    where $\\vec{n}$ is normalized eigenvector corresponding to the softest mode.\n    the The bias is applied to a specified set of atoms at regular intervals,\n    with optional stability checks and logging.\n\n    Args:\n        biased_force (openmm.CustomExternalForce):\n            The OpenMM force object that will receive GADES bias forces.\n            Must be created using `getGADESBiasForce()`.\n        bias_atom_indices (Sequence[int]):\n            Indices of atoms that should receive the bias force.\n        hess_func (Callable):\n            A user-supplied function returning the Hessian matrix for the system.\n            Must accept `(system, positions, atom_indices, step_size, platform)`\n            as input and return a 2D array-like Hessian. Choose one of \n            `GADES.utils.compute_hessian_force_fd_richardson`, \n            `GADES.utils.compute_hessian_force_fd_block_serial`, or\n            `GADES.utils.compute_hessian_force_fd_block_parallel`. We suggest\n            the Richardson variant.\n        clamp_magnitude (float):\n            Maximum allowed magnitude for each component of the bias force,\n            used to prevent unphysical updates or exploration of irrelavant\n            regions.\n        kappa (float):\n            Scaling factor (0 &lt; \u03ba &lt; 1) applied to the bias force along the\n            softest eigenmode. GADES is designed for exploration applications\n            with \u03ba=0.9. Values larger than 1 will lead to the system lingering\n            in the transition regions. Values smaller than 0.9 limit the\n            maximum gradient GADES is able to overcome. We suggest controling\n            this with `clamp_magnitude` instead of `kappa` since `kappa` will\n            damp __all__ forces while the clamp is only effective in high-\n            gradient regions.\n        interval (int):\n            Number of simulation steps between bias force updates. Values\n            less than 100 are overridden to 110 internally to ensure stability.\n            Smaller values make for a more accurate bias direction, at the \n            expense of computational cost. In our experience, a value of \n            ~2000 is a good place to start.\n        stability_interval (int, optional):\n            Number of steps between stability checks based on kinetic\n            temperature. If None, only post-bias stability checks are used.\n            This check ensures that the system doesn't stray too far from \n            the set temperature by turning the bias off if the temperature\n            rises &gt;50 K of the simulation temeprature. We suggest a value of\n            500 steps for most simulations.\n        logfile_prefix (str, optional):\n            Prefix for log files. If provided, the following files are created:\n              - `&lt;prefix&gt;_evec.log`: trajectory of softest-mode eigenvectors\n              - `&lt;prefix&gt;_eval.log`: trajectory of  sorted eigenvalue spectra\n              - `&lt;prefix&gt;_biased_atoms.xyz`: biased atom trajectories in XYZ format\n\n    Raises:\n        ValueError: If `interval` is not a positive integer.\n        OSError: If log files cannot be created when `logfile_prefix` is set.\n\n    Examples:\n        &gt;&gt;&gt; from GADES import getGADESBiasForce, GADESForceUpdater\n        &gt;&gt;&gt; from GADES.utils import compute_hessian_force_fd_richardson as hessian\n        &gt;&gt;&gt; system = ...\n        &gt;&gt;&gt; simulation = ...\n        &gt;&gt;&gt; biasing_atom_ids = ...\n        &gt;&gt;&gt; GAD_force = getGADESBiasForce(system.getNumParticles())\n        &gt;&gt;&gt; GADESupdater = GADESForceUpdater(\n                            biased_force=GAD_force, \n                            bias_atom_indices=biasing_atom_ids,\n                            hess_func=hessian, \n                            clamp_magnitude=2500,\n                            kappa=0.9, \n                            interval=1000, \n                            stability_interval=500, \n                            logfile_prefix=\"GADES_log\"\n                            )\n        &gt;&gt;&gt; simulation.reporters.append(GADESupdater)\n        &gt;&gt;&gt; simulation.step(10000)\n\n    \"\"\"\n    self.biased_force = biased_force\n    self.bias_atom_indices = bias_atom_indices\n    self.hess_func = hess_func\n    self.clamp_magnitude = clamp_magnitude\n    if interval &lt; 100:\n        print(\"\\033[1;33m[GADES| WARNING] Bias update interval must be larger than 100 steps to ensure system stability. Changing the frequency to 110 steps internally...\\033[0m\")\n        self.interval = 110\n    else:\n        self.interval = interval\n    self.kappa = kappa\n    self.hess_step_size = 1e-5\n    self.check_stability = False\n    self.is_biasing = False\n    self.s_interval = stability_interval\n\n    # post bias update check\n    self.next_postbias_check_step = None\n\n    # logging\n    self.atom_symbols = None\n    self.logfile_prefix = logfile_prefix\n    self._evec_log = None\n    self._eval_log = None\n    self._xyz_log = None\n\n    if logfile_prefix is not None:\n        # register with atexit for safe handling of log files\n        atexit.register(self._close_logs)\n\n        self._evec_log = open(f\"{logfile_prefix}_evec.log\", \"w\")\n        self._evec_log.write(\"# Softest-mode eigenvector at each step (one per line)\\n\")\n        self._evec_log.write(\"# Columns: step, eigenvector components (flattened)\\n\")\n        self._evec_log.flush()\n        self._eval_log = open(f\"{logfile_prefix}_eval.log\", \"w\")\n        self._eval_log.write(\"# Sorted eigenvalue spectrum at each step (one line per frame)\\n\")\n        self._eval_log.write(\"# Columns: step, eigenvalues from smallest to largest\\n\")\n        self._eval_log.flush()\n\n        self._xyz_log  = open(f\"{logfile_prefix}_biased_atoms.xyz\", \"w\")\n        self._xyz_log.write(\"# Trajectory of biased atoms only\\n\")\n        self._xyz_log.write(\"# Each frame follows XYZ format: N_atoms, comment, atom lines\\n\")\n        self._xyz_log.write(\"# Coordinates are in nanometers; atoms are labeled 'C' by default\\n\")\n        self._xyz_log.flush()\n</code></pre>"},{"location":"reference/GADES/#GADES.GADESForceUpdater.set_kappa","title":"set_kappa","text":"<pre><code>set_kappa(kappa)\n</code></pre> <p>Update the scaling factor \u03ba used for the GADES bias force.</p> <p>This method is the setter of <code>kappa</code>, which determines how strongly the bias is applied along the softest Hessian eigenmode. The new value will be used in all subsequent bias updates. Note that there are no checks on the provided value for <code>kappa</code> for maximum flexibility. However,  GADES is designed for exploration applications with 0 &lt; \u03ba &lt; 1. Stability and behavior has not been tested for \u03ba outside this range. Values larger than 1 will lead to the system lingering in the transition regions.  Values smaller than 0.9 limit the maximum gradient GADES is able to  overcome. We suggest controling this with <code>clamp_magnitude</code> instead of  <code>kappa</code> since <code>kappa</code> will damp all forces while the clamp is only  effective in high-gradient regions. </p> <p>Parameters:</p> Name Type Description Default <code>kappa</code> <code>float</code> <p>New scaling factor \u03ba for the bias force.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; GADESupdater.set_kappa(0.8)\n&gt;&gt;&gt; print(updater.kappa)\n0.8\n</code></pre> Source code in <code>GADES/gades.py</code> <pre><code>def set_kappa(self, kappa: float) -&gt; None:\n    \"\"\"\n    Update the scaling factor \u03ba used for the GADES bias force.\n\n    This method is the setter of `kappa`, which determines how strongly\n    the bias is applied along the softest Hessian eigenmode. The new value\n    will be used in all subsequent bias updates. Note that there are no checks\n    on the provided value for `kappa` for maximum flexibility. However, \n    GADES is designed for exploration applications with 0 &lt; \u03ba &lt; 1. Stability\n    and behavior has not been tested for \u03ba outside this range. Values larger\n    than 1 will lead to the system lingering in the transition regions. \n    Values smaller than 0.9 limit the maximum gradient GADES is able to \n    overcome. We suggest controling this with `clamp_magnitude` instead of \n    `kappa` since `kappa` will damp __all__ forces while the clamp is only \n    effective in high-gradient regions. \n\n    Args:\n        kappa (float):\n            New scaling factor \u03ba for the bias force.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; GADESupdater.set_kappa(0.8)\n        &gt;&gt;&gt; print(updater.kappa)\n        0.8\n    \"\"\"\n    self.kappa = kappa\n    return None\n</code></pre>"},{"location":"reference/GADES/#GADES.GADESForceUpdater.set_hess_step_size","title":"set_hess_step_size","text":"<pre><code>set_hess_step_size(delta)\n</code></pre> <p>Update the displacement step size used for numerical Hessian calculations.</p> <p>The Hessian is computed via finite-difference displacements of the atomic coordinates. This method updates the step size <code>delta</code> used in those displacements, which can affect both accuracy and numerical stability. The Richardson method-based Hessian calculators are less prone to  numerical errors due to small/large step sizes.</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>float</code> <p>New displacement step size (in nanometers) for Hessian evaluation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>delta</code> is not positive.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; GADESupdater.set_hess_step_size(1e-4)\n&gt;&gt;&gt; print(updater.hess_step_size)\n0.0001\n</code></pre> Source code in <code>GADES/gades.py</code> <pre><code>def set_hess_step_size(self, delta: float) -&gt; None:\n    \"\"\"\n    Update the displacement step size used for numerical Hessian calculations.\n\n    The Hessian is computed via finite-difference displacements of the\n    atomic coordinates. This method updates the step size `delta` used in\n    those displacements, which can affect both accuracy and numerical stability.\n    The Richardson method-based Hessian calculators are less prone to \n    numerical errors due to small/large step sizes.\n\n    Args:\n        delta (float):\n            New displacement step size (in nanometers) for Hessian evaluation.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If `delta` is not positive.\n\n    Examples:\n        &gt;&gt;&gt; GADESupdater.set_hess_step_size(1e-4)\n        &gt;&gt;&gt; print(updater.hess_step_size)\n        0.0001\n    \"\"\"\n    if delta &lt;= 0:\n        raise ValueError(\"Hessian step size `delta` cannot be zero or negative.\")\n    self.hess_step_size = delta\n    return None\n</code></pre>"},{"location":"reference/GADES/#GADES.GADESForceUpdater.describeNextReport","title":"describeNextReport","text":"<pre><code>describeNextReport(simulation)\n</code></pre> <p>Define when the reporter should run next and what data it requires.</p> <p>This method is required by the OpenMM <code>Reporter</code> interface and must be implemented in all reporter subclasses. It determines how many steps until the next reporting event and specifies which data types (positions, velocities, forces, energies, volumes) are needed at that time.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>The OpenMM Simulation object providing the current step and state.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[int, bool, bool, bool, bool, bool]</code> <p>A 6-element tuple with the following contents:   - steps (int): Number of steps until the next report.   - needsPositions (bool): Always False.   - needsVelocities (bool): Always False.   - needsForces (bool): Always False.   - needsEnergy (bool): Always False.   - needsVolume (bool): Always False.</p> Notes <ul> <li>Even though this method is not part of the intended public API for   <code>GADESForceUpdater</code>, it must remain public (no leading underscore)   because OpenMM requires <code>describeNextReport</code> to be defined.</li> <li>Internally, this method:<ul> <li>Ensures atom symbols are initialized for logging.</li> <li>Schedules the next bias update, stability check, or post-bias check.</li> <li>Sets internal flags (<code>is_biasing</code>, <code>check_stability</code>) for use in   subsequent reporting steps.</li> </ul> </li> </ul> Source code in <code>GADES/gades.py</code> <pre><code>def describeNextReport(self, simulation: openmm.app.Simulation) -&gt; tuple[int, bool, bool, bool, bool, bool]:\n    \"\"\"\n    Define when the reporter should run next and what data it requires.\n\n    This method is required by the OpenMM `Reporter` interface and must be\n    implemented in all reporter subclasses. It determines how many steps\n    until the next reporting event and specifies which data types (positions,\n    velocities, forces, energies, volumes) are needed at that time.\n\n    Args:\n        simulation (openmm.app.Simulation):\n            The OpenMM Simulation object providing the current step and state.\n\n    Returns:\n        tuple:\n            A 6-element tuple with the following contents:\n              - steps (int): Number of steps until the next report.\n              - needsPositions (bool): Always False.\n              - needsVelocities (bool): Always False.\n              - needsForces (bool): Always False.\n              - needsEnergy (bool): Always False.\n              - needsVolume (bool): Always False.\n\n    Notes:\n        - Even though this method is not part of the intended public API for\n          `GADESForceUpdater`, it must remain public (no leading underscore)\n          because OpenMM requires `describeNextReport` to be defined.\n        - Internally, this method:\n            * Ensures atom symbols are initialized for logging.\n            * Schedules the next bias update, stability check, or post-bias check.\n            * Sets internal flags (`is_biasing`, `check_stability`) for use in\n              subsequent reporting steps.\n    \"\"\"\n    step = simulation.currentStep\n\n    # Extract atom symbols on the first call for logging\n    self._ensure_atom_symbols(simulation)\n\n    # Compute time to each type of report\n    steps_to_check = (\n        self.s_interval - step % self.s_interval\n        if self.s_interval else np.inf\n    )\n    steps_to_bias = self.interval - step % self.interval\n\n    if self.next_postbias_check_step is not None:\n        steps_to_postbias = max(self.next_postbias_check_step - step, 0)\n    else:\n        steps_to_postbias = np.inf\n\n    # Choose the next event\n    steps = min(steps_to_bias, steps_to_check, steps_to_postbias)\n\n    # Set flags *before* return\n    self.is_biasing = (steps == steps_to_bias)\n    is_forced_check = (steps == steps_to_postbias)\n    is_regular_check = (steps == steps_to_check)\n\n    self.check_stability = is_forced_check or is_regular_check\n\n    return (steps, False, False, False, False, False)\n</code></pre>"},{"location":"reference/GADES/#GADES.GADESForceUpdater.report","title":"report","text":"<pre><code>report(simulation, state)\n</code></pre> <p>Apply (or remove) GADES bias forces at the current simulation step.</p> <p>This method fulfills the OpenMM <code>Reporter</code> interface requirement. It uses internal scheduling flags set by <code>describeNextReport</code> to decide whether to:   1) perform a stability check and remove bias if unstable,   2) update/apply the GADES bias forces, or   3) do nothing this step. Parameter updates are pushed to the OpenMM context when modifications occur.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>The OpenMM Simulation object (provides context, step counter, etc.).</p> required <code>state</code> <code>State</code> <p>Current simulation state. Unused here, but required by the Reporter API.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Side Effects <ul> <li>Calls <code>_get_gad_force</code> to compute biased forces when <code>is_biasing</code> is True.</li> <li>Updates <code>self.biased_force</code> per-atom parameters and pushes them with   <code>updateParametersInContext(simulation.context)</code>.</li> <li>Clears or sets scheduling flags:<ul> <li><code>self.check_stability</code> \u2192 False after a stability-handling step.</li> <li><code>self.is_biasing</code> \u2192 False after bias has been applied.</li> <li><code>self.next_postbias_check_step</code> \u2192 set to <code>step + 100</code> after applying bias,   or cleared when the scheduled post-bias check is reached.</li> </ul> </li> <li>Emits informational messages to stdout about actions taken.</li> </ul> Internal Helpers <ul> <li><code>remove_bias()</code> (internal use only):     Reset the per-atom bias parameters to <code>(0.0, 0.0, 0.0)</code> for all     <code>bias_atom_indices</code>, effectively disabling the bias.</li> <li><code>apply_bias()</code> (internal use only):     Compute the current GADES bias via <code>_get_gad_force(simulation)</code> and set     per-atom parameters accordingly for all <code>bias_atom_indices</code>.</li> </ul> Notes <ul> <li>This method is typically triggered by OpenMM according to the schedule   returned by <code>describeNextReport</code>. It defensively calls   <code>_ensure_atom_symbols(simulation)</code> in case the reporter was invoked   before <code>describeNextReport</code>.</li> <li>If <code>self.check_stability</code> is True, the method first evaluates stability via   <code>_is_stable(simulation)</code>:<ul> <li>If unstable (\u0394T &gt; 50 K from target), the bias is removed for safety.</li> <li>If stable and <code>self.is_biasing</code> is True, the bias is (re)applied and a   post-bias check is scheduled in 100 steps.</li> </ul> </li> <li>If neither <code>self.check_stability</code> nor <code>self.is_biasing</code> is set, the method   performs no action for the current step.</li> </ul> Source code in <code>GADES/gades.py</code> <pre><code>def report(self, simulation: openmm.app.Simulation, \n           state: openmm.State) -&gt; None:\n    \"\"\"\n    Apply (or remove) GADES bias forces at the current simulation step.\n\n    This method fulfills the OpenMM `Reporter` interface requirement. It uses\n    internal scheduling flags set by `describeNextReport` to decide whether to:\n      1) perform a stability check and remove bias if unstable,\n      2) update/apply the GADES bias forces, or\n      3) do nothing this step.\n    Parameter updates are pushed to the OpenMM context when modifications occur.\n\n    Args:\n        simulation (openmm.app.Simulation):\n            The OpenMM Simulation object (provides context, step counter, etc.).\n        state (openmm.State):\n            Current simulation state. Unused here, but required by the Reporter API.\n\n    Returns:\n        None\n\n    Side Effects:\n        - Calls `_get_gad_force` to compute biased forces when `is_biasing` is True.\n        - Updates `self.biased_force` per-atom parameters and pushes them with\n          `updateParametersInContext(simulation.context)`.\n        - Clears or sets scheduling flags:\n            * `self.check_stability` \u2192 False after a stability-handling step.\n            * `self.is_biasing` \u2192 False after bias has been applied.\n            * `self.next_postbias_check_step` \u2192 set to `step + 100` after applying bias,\n              or cleared when the scheduled post-bias check is reached.\n        - Emits informational messages to stdout about actions taken.\n\n    Internal Helpers:\n        - `remove_bias()` (internal use only):\n            Reset the per-atom bias parameters to `(0.0, 0.0, 0.0)` for all\n            `bias_atom_indices`, effectively disabling the bias.\n        - `apply_bias()` (internal use only):\n            Compute the current GADES bias via `_get_gad_force(simulation)` and set\n            per-atom parameters accordingly for all `bias_atom_indices`.\n\n    Notes:\n        - This method is typically triggered by OpenMM according to the schedule\n          returned by `describeNextReport`. It defensively calls\n          `_ensure_atom_symbols(simulation)` in case the reporter was invoked\n          before `describeNextReport`.\n        - If `self.check_stability` is True, the method first evaluates stability via\n          `_is_stable(simulation)`:\n            * If unstable (\u0394T &gt; 50 K from target), the bias is removed for safety.\n            * If stable and `self.is_biasing` is True, the bias is (re)applied and a\n              post-bias check is scheduled in 100 steps.\n        - If neither `self.check_stability` nor `self.is_biasing` is set, the method\n          performs no action for the current step.\n    \"\"\"\n    step = simulation.currentStep\n\n    # Defensive fallback in case describeNextReport hasn't been called yet\n    self._ensure_atom_symbols(simulation)\n\n    def remove_bias():\n        for idx in self.bias_atom_indices:\n            self.biased_force.setParticleParameters(idx, idx, (0.0, 0.0, 0.0))\n\n    def apply_bias():\n        biased_forces = self._get_gad_force(simulation)\n        for i, idx in enumerate(self.bias_atom_indices):\n            self.biased_force.setParticleParameters(idx, idx, tuple(biased_forces[i]))\n\n    if self.check_stability:\n        is_stable = self._is_stable(simulation)\n        if not is_stable:\n            print(f\"\\033[1;31m[GADES | step {step}] System is unstable: Removing bias until next cycle...\\033[0m\", flush=True)\n            remove_bias()\n        elif self.is_biasing:\n            print(f\"\\033[1;32m[GADES | step {step}] Updating bias forces...\\033[0m\", flush=True)\n            apply_bias()\n            self.next_postbias_check_step = step + 100\n\n        self.biased_force.updateParametersInContext(simulation.context)\n        self.check_stability = False\n        self.is_biasing = False\n        if step == self.next_postbias_check_step:\n            self.next_postbias_check_step = None\n        return None\n\n    if self.is_biasing:\n        print(f\"\\033[1;32m[GADES | step {step}] Updating bias forces...\\033[0m\", flush=True)\n        apply_bias()\n        self.biased_force.updateParametersInContext(simulation.context)\n        self.is_biasing = False\n        self.next_postbias_check_step = step + 100\n        return None\n\n    # If neither flag is True, do nothing\n    return None\n</code></pre>"},{"location":"reference/GADES/#GADES.getGADESBiasForce","title":"getGADESBiasForce","text":"<pre><code>getGADESBiasForce(n_particles)\n</code></pre> <p>Create a custom OpenMM force object for GADES biasing.</p> <p>This function constructs an OpenMM <code>CustomExternalForce</code> that applies per-particle forces in the form:</p> \\[F(x, y, z) = f_x * x + f_y * y + f_z * z\\] <p>where <code>fx</code>, <code>fy</code>, and <code>fz</code> are per-particle parameters that can be updated during a simulation. The force is assigned to group <code>1</code> so that it can be easily separated from other forces in analysis or reporting.</p> <p>Parameters:</p> Name Type Description Default <code>n_particles</code> <code>int</code> <p>Number of particles in the system. Each particle will be assigned its own <code>(fx, fy, fz)</code> parameter set.</p> required <p>Returns:</p> Type Description <code>CustomExternalForce</code> <p>openmm.CustomExternalForce: A <code>CustomExternalForce</code> object configured with per-particle force parameters for GADES biasing.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>n_particles</code> is negative.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from GADES import getGADESBiasForce\n&gt;&gt;&gt; system = ...\n&gt;&gt;&gt; force = GAD_force = getGADESBiasForce(system.getNumParticles())\n&gt;&gt;&gt; system.addForce(GAD_force)\n</code></pre> Source code in <code>GADES/gades.py</code> <pre><code>def getGADESBiasForce(n_particles: int) -&gt; CustomExternalForce:\n    \"\"\"\n    Create a custom OpenMM force object for GADES biasing.\n\n    This function constructs an OpenMM `CustomExternalForce` that applies\n    per-particle forces in the form:\n\n    $$F(x, y, z) = f_x * x + f_y * y + f_z * z$$\n\n    where `fx`, `fy`, and `fz` are per-particle parameters that can be updated\n    during a simulation. The force is assigned to group `1` so that it can be\n    easily separated from other forces in analysis or reporting.\n\n    Args:\n        n_particles (int):\n            Number of particles in the system. Each particle will be assigned\n            its own `(fx, fy, fz)` parameter set.\n\n    Returns:\n        openmm.CustomExternalForce:\n            A `CustomExternalForce` object configured with per-particle force\n            parameters for GADES biasing.\n\n    Raises:\n        ValueError: If `n_particles` is negative.\n\n    Examples:\n        &gt;&gt;&gt; from GADES import getGADESBiasForce\n        &gt;&gt;&gt; system = ...\n        &gt;&gt;&gt; force = GAD_force = getGADESBiasForce(system.getNumParticles())\n        &gt;&gt;&gt; system.addForce(GAD_force)\n    \"\"\"\n    force = CustomExternalForce(\"fx*x+fy*y+fz*z\")\n    force.addPerParticleParameter(\"fx\")\n    force.addPerParticleParameter(\"fy\")\n    force.addPerParticleParameter(\"fz\")\n    for i in range(n_particles):\n        force.addParticle(i, [0.0, 0.0, 0.0])\n    force.setForceGroup(1)\n    return force\n</code></pre>"},{"location":"reference/utils/","title":"<code>utils.py</code> API reference","text":""},{"location":"reference/utils/#GADES.utils.muller_brown_potential_base","title":"muller_brown_potential_base","text":"<pre><code>muller_brown_potential_base(x)\n</code></pre> <p>2D Muller-Brown potential.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>(2, ) vector of x0 and x1</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Muller-Brown potential value at <code>x</code></p> Source code in <code>GADES/utils.py</code> <pre><code>def muller_brown_potential_base(x: jnp.ndarray) -&gt; float:\n    \"\"\"\n    2D Muller-Brown potential.\n\n    Args:\n        x (jax.ndarray): (2, ) vector of x0 and x1\n\n    Returns:\n        float: Muller-Brown potential value at `x`\n    \"\"\"\n    A = jnp.array([-200, -100, -170, 15])\n    a = jnp.array([-1, -1, -6.5, 0.7])\n    b = jnp.array([0, 0, 11, 0.6])\n    c = jnp.array([-10, -10, -6.5, 0.7])\n    x0 = jnp.array([1, 0, -0.5, -1])\n    y0 = jnp.array([0, 0.5, 1.5, 1])\n\n    z = jnp.sum(\n        A * jnp.exp(\n            a * (x[0] - x0) ** 2 +\n            b * (x[0] - x0) * (x[1] - y0) +\n            c * (x[1] - y0) ** 2\n        )\n    )\n    return z\n</code></pre>"},{"location":"reference/utils/#GADES.utils.muller_brown_potential","title":"muller_brown_potential","text":"<pre><code>muller_brown_potential(X)\n</code></pre> <p><code>vmap</code> version of the Muller-Brown potential.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>(N, 2) input x0 and x1 values</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jax.ndarray: (N, 1) Muller-Brown potential values</p> Source code in <code>GADES/utils.py</code> <pre><code>@jit\ndef muller_brown_potential(X: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"\n    `vmap` version of the Muller-Brown potential.\n\n    Args:\n        X (jax.ndarray): (N, 2) input x0 and x1 values\n\n    Returns:\n        jax.ndarray: (N, 1) Muller-Brown potential values\n    \"\"\"\n    return vmap(muller_brown_potential_base, in_axes=(0))(X)\n</code></pre>"},{"location":"reference/utils/#GADES.utils.muller_brown_force_base","title":"muller_brown_force_base","text":"<pre><code>muller_brown_force_base(x)\n</code></pre> <p>Muller-Brown forces at <code>x</code> calculated using AD.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>(2, ) position</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jax.ndarray: (2, ) forces vector [-dU/dx0, -dU/dx1]</p> Source code in <code>GADES/utils.py</code> <pre><code>@jit\ndef muller_brown_force_base(x: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\" Muller-Brown forces at `x` calculated using AD.\n\n    Args:\n        x (jax.ndarray): (2, ) position\n\n    Returns:\n        jax.ndarray: (2, ) forces vector [-dU/dx0, -dU/dx1]\n    \"\"\"\n    return -grad(muller_brown_potential_base)(x)\n</code></pre>"},{"location":"reference/utils/#GADES.utils.muller_brown_force","title":"muller_brown_force","text":"<pre><code>muller_brown_force(X)\n</code></pre> <p><code>vmap</code> version of Muller-Brown forces at <code>X</code> calculated using AD.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>(N, 2) position</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jax.ndarray: (N, 2) forces vectors [-dU/dx0, -dU/dx1]</p> Source code in <code>GADES/utils.py</code> <pre><code>@jit\ndef muller_brown_force(X: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\" `vmap` version of Muller-Brown forces at `X` calculated using AD.\n\n    Args:\n        X (jax.ndarray): (N, 2) position\n\n    Returns:\n        jax.ndarray: (N, 2) forces vectors [-dU/dx0, -dU/dx1]\n    \"\"\"\n    return vmap(muller_brown_force_base, in_axes=(0))(X)\n</code></pre>"},{"location":"reference/utils/#GADES.utils.muller_brown_hess_base","title":"muller_brown_hess_base","text":"<pre><code>muller_brown_hess_base(x)\n</code></pre> <p>Muller-Brown Hessian at <code>x</code> calculated using AD.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>(2, ) position</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jax.ndarray: (2, 2) Hessian matrix [[ddU/ddx0, ddU/dx0dx1], [ddU/dx1dx0, ddU/ddx1]]</p> Source code in <code>GADES/utils.py</code> <pre><code>@jit\ndef muller_brown_hess_base(x: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\" Muller-Brown Hessian at `x` calculated using AD.\n\n    Args:\n        x (jax.ndarray): (2, ) position\n\n    Returns:\n        jax.ndarray: (2, 2) Hessian matrix [[ddU/ddx0, ddU/dx0dx1], [ddU/dx1dx0, ddU/ddx1]]\n    \"\"\"\n    return hessian(muller_brown_potential_base)(x)\n</code></pre>"},{"location":"reference/utils/#GADES.utils.muller_brown_hess","title":"muller_brown_hess","text":"<pre><code>muller_brown_hess(X)\n</code></pre> <p><code>vmap</code> version of Muller-Brown Hessian at <code>x</code> calculated using AD.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>(N, 2) position</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jax.ndarray: (N, 2, 2) Hessian matrix [[ddU/ddx0, ddU/dx0dx1], [ddU/dx1dx0, ddU/ddx1]]</p> Source code in <code>GADES/utils.py</code> <pre><code>@jit\ndef muller_brown_hess(X: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\" `vmap` version of Muller-Brown Hessian at `x` calculated using AD.\n\n    Args:\n        X (jax.ndarray): (N, 2) position\n\n    Returns:\n        jax.ndarray: (N, 2, 2) Hessian matrix [[ddU/ddx0, ddU/dx0dx1], [ddU/dx1dx0, ddU/ddx1]]\n    \"\"\"\n    return vmap(muller_brown_hess_base, in_axes=(0))(X)\n</code></pre>"},{"location":"reference/utils/#GADES.utils.muller_brown_gad_force_base","title":"muller_brown_gad_force_base","text":"<pre><code>muller_brown_gad_force_base(position, kappa=0.9)\n</code></pre> <p>GADES forces for the Muller-Brown potential at <code>position</code> calculated using AD.  Calculates the total forces, then finds the most-negative eigenvalue and  the corresponding eigenvector of the Hessian and returns negative <code>kappa</code>  times the force projected in the eigenvector direction as the biasing force.</p> <p>Args:       position (jax.ndarray): (2, ) position       kappa (float): GAD intensity parameter. Determines how much of the GAD        force is used for biasing. <code>kappa=1</code> is 100% and <code>kappa=0</code> is none.</p> <p>Returns:       jax.ndarray: (2, ) GAD bias forces vector</p> Source code in <code>GADES/utils.py</code> <pre><code>@jit\ndef muller_brown_gad_force_base(position: jnp.ndarray, kappa: Optional[float]=0.9) -&gt; jnp.ndarray:\n  \"\"\" GADES forces for the Muller-Brown potential at `position` calculated using AD. \n  Calculates the total forces, then finds the most-negative eigenvalue and \n  the corresponding eigenvector of the Hessian and returns negative `kappa` \n  times the force projected in the eigenvector direction as the biasing force.\n\n    Args:\n        position (jax.ndarray): (2, ) position\n        kappa (float): GAD intensity parameter. Determines how much of the GAD \n        force is used for biasing. `kappa=1` is 100% and `kappa=0` is none.\n\n    Returns:\n        jax.ndarray: (2, ) GAD bias forces vector\n    \"\"\"\n\n  # unbiased forces\n  forces_u = muller_brown_force_base(position)\n\n  # biased forces (softened by kappa)\n  h = muller_brown_hess_base(position)\n  w, v = jnp.linalg.eigh(h)\n  n = v[:,0]\n  n = n/jnp.sqrt(jnp.dot(n,n))\n  forces_b = -jnp.dot(forces_u,n)*n\n  forces_b *= kappa\n\n  return forces_b\n</code></pre>"},{"location":"reference/utils/#GADES.utils.null_force","title":"null_force","text":"<pre><code>null_force(X)\n</code></pre> <p>Helper function for return Null forces. Used for unbiased runs.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>(d, ) array of position</p> required <p>Returns:</p> Type Description <code>(d,)</code> <p>Forces vector of all zeros</p> Source code in <code>GADES/utils.py</code> <pre><code>@jit\ndef null_force(X: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"\n    Helper function for return Null forces. Used for unbiased runs.\n\n    Args:\n        X (jax.ndarray): (d, ) array of position\n\n    Returns:\n        (d, ): Forces vector of all zeros\n    \"\"\"\n    return jnp.zeros_like(X)\n</code></pre>"},{"location":"reference/utils/#GADES.utils.inverse_power_iteration","title":"inverse_power_iteration","text":"<pre><code>inverse_power_iteration(A, mu=0.0, num_iters=100, tol=1e-06)\n</code></pre> <p>Computes the smallest eigenvalue and eigenvector of a matrix using inverse power iteration.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ndarray</code> <p>The square matrix (n x n) for which to find the eigenvalue/vector pair with eval closest to mu.</p> required <code>mu</code> <code>float</code> <p>Shift value applied to A to condition search on eigenvalue/vector pair with eval closest to mu.</p> <code>0.0</code> <code>num_iters</code> <code>int</code> <p>Maximum number of iterations.</p> <code>100</code> <code>tol</code> <code>float</code> <p>Convergence tolerance for the eigenvector.</p> <code>1e-06</code> <p>Returns:</p> Name Type Description <code>eigenvalue</code> <code>float</code> <p>Smallest eigenvalue of the matrix.</p> <code>eigenvector</code> <code>ndarray</code> <p>Corresponding eigenvector (normalized).</p> Source code in <code>GADES/utils.py</code> <pre><code>@jit\ndef inverse_power_iteration(A: jnp.ndarray, mu:callable[float]=0.,\n                            num_iters:callable[int]=100, tol:callable[float]=1e-6) -&gt; tuple[float, jnp.ndarray]:\n    \"\"\"\n    Computes the smallest eigenvalue and eigenvector of a matrix using inverse power iteration.\n\n    Parameters:\n        A (jax.numpy.ndarray): The square matrix (n x n) for which to find the eigenvalue/vector pair with eval closest to mu.\n        mu (float): Shift value applied to A to condition search on eigenvalue/vector pair with eval closest to mu.\n        num_iters (int): Maximum number of iterations.\n        tol (float): Convergence tolerance for the eigenvector.\n\n    Returns:\n        eigenvalue (float): Smallest eigenvalue of the matrix.\n        eigenvector (jax.numpy.ndarray): Corresponding eigenvector (normalized).\n    \"\"\"\n    n = A.shape[0]\n\n    # Initialize a random vector as initial guess for evec\n    b_k = random.normal(random.PRNGKey(0), shape=(n,))\n    b_k = b_k / jnp.linalg.norm(b_k)  # Normalize initial vector\n\n    # Applying shift to matrix A -&gt; A - mu*I\n    A_shift = A - mu*jnp.identity(n)\n\n    # Body function implementing inverse power iteration\n    def body_fun(state):\n        b_k, prev_b_k, iteration = state\n        # Solve (A - mu*I)x = b for x as prescribed by inverse power iteration\n        b_k_new = jnp.linalg.solve(A_shift, b_k)\n        b_k_new = b_k_new / jnp.linalg.norm(b_k_new)  # Normalize the vector\n        return b_k_new, b_k, iteration + 1\n\n    # Conditional function defining convergence\n    def cond_fun(state):\n        b_k, prev_b_k, iteration = state\n        not_converged = jnp.linalg.norm(b_k - prev_b_k) &gt; tol\n        not_max_iter = iteration &lt; num_iters\n        return not_converged &amp; not_max_iter\n\n    # Initialize state with (current vector, previous vector, iteration count)\n    initial_state = (b_k, jnp.zeros_like(b_k), 0)\n\n    # Iterate using lax.while_loop\n    final_state = lax.while_loop(cond_fun, body_fun, initial_state)\n\n    # Extract the final vector\n    b_k = final_state[0]\n\n    # Compute the smallest eigenvalue using the Rayleigh quotient\n    eigenvalue = jnp.dot(b_k, jnp.dot(A, b_k)) / jnp.dot(b_k, b_k)\n\n    return eigenvalue, b_k\n</code></pre>"},{"location":"reference/utils/#GADES.utils.baoab_langevin_integrator","title":"baoab_langevin_integrator","text":"<pre><code>baoab_langevin_integrator(positions, velocities, forces_u, forces_b, mass, gamma, dt, kBT, force_function_u, force_function_b, n_steps=1)\n</code></pre> <p>BAOAB Langevin integrator based on Leimkuhler and Matthews (2013). https://dx.doi.org/10.1093/amrx/abs010</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>ndarray</code> <p>Initial positions (shape: [D, ], where D is dimensionality).</p> required <code>velocities</code> <code>ndarray</code> <p>Initial velocities (shape: [D, ]).</p> required <code>forces_u</code> <code>ndarray</code> <p>Initial unbiased forces (shape: [D, ]).</p> required <code>forces_b</code> <code>ndarray</code> <p>Initial biased forces (shape: [D, ]).</p> required <code>mass</code> <code>float</code> <p>Mass of the particles (scalar).</p> required <code>gamma</code> <code>float</code> <p>Friction coefficient. (scalar).</p> required <code>dt</code> <code>float</code> <p>Time step. (scalar).</p> required <code>n_steps</code> <code>int</code> <p>Number of simulation steps. (scalar).</p> <code>1</code> <code>kBT</code> <code>float</code> <p>Thermal energy (\\(k_B T\\)). (scalar).</p> required <code>force_function_u</code> <code>callable</code> <p>Function to compute unbiased forces given positions (returns forces of shape [D, ]).</p> required <code>force_function_b</code> <code>callable</code> <p>Function to compute biased forces given positions (returns forces of shape [D, ]).</p> required <p>Returns:</p> Name Type Description <code>positions</code> <code>ndarray</code> <p>New positions (shape: [D, ]).</p> <code>velocities</code> <code>ndarray</code> <p>New velocities (shape: [D, ]).</p> <code>forces_u</code> <code>ndarray</code> <p>Unbiased forces at new position (shape: [D, ]).</p> <code>forces_b</code> <code>ndarray</code> <p>Biased forces at new position (shape: [D, ]).</p> Source code in <code>GADES/utils.py</code> <pre><code>def baoab_langevin_integrator(positions: jnp.ndarray, velocities: jnp.ndarray, \n                              forces_u: jnp.ndarray, forces_b: jnp.ndarray, \n                              mass: float, gamma: float, dt:float, \n                              kBT:float, force_function_u: Callable, \n                              force_function_b: Callable, \n                              n_steps:callable[int]=1) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray, jnp.ndarray]:\n    r\"\"\"\n    BAOAB Langevin integrator based on Leimkuhler and Matthews (2013).\n    https://dx.doi.org/10.1093/amrx/abs010\n\n    Parameters:\n        positions (jax.ndarray): Initial positions (shape: [D, ], where D is dimensionality).\n        velocities (jax.ndarray): Initial velocities (shape: [D, ]).\n        forces_u (jax.ndarray): Initial unbiased forces (shape: [D, ]).\n        forces_b (jax.ndarray): Initial biased forces (shape: [D, ]).\n        mass (float): Mass of the particles (scalar).\n        gamma (float): Friction coefficient. (scalar).\n        dt (float): Time step. (scalar).\n        n_steps (int): Number of simulation steps. (scalar).\n        kBT (float): Thermal energy (\\(k_B T\\)). (scalar).\n        force_function_u (callable): Function to compute unbiased forces given positions (returns forces of shape [D, ]).\n        force_function_b (callable): Function to compute biased forces given positions (returns forces of shape [D, ]).\n\n    Returns:\n        positions (jax.ndarray): New positions (shape: [D, ]).\n        velocities (jax.ndarray): New velocities (shape: [D, ]).\n        forces_u (jax.ndarray): Unbiased forces at new position (shape: [D, ]).\n        forces_b (jax.ndarray): Biased forces at new position (shape: [D, ]).\n    \"\"\"\n    dim = positions.shape[0]\n\n    # Precompute constants\n    c1 = jnp.exp(-gamma * dt)\n    c3 = jnp.sqrt(kBT * (1 - c1**2))\n    inv_mass = jnp.reciprocal(mass)\n    inv_mass_sqrt = jnp.reciprocal(jnp.sqrt(mass))\n\n    for step in range(n_steps):\n\n        # Step B (First half-step momentum update)\n        forces = forces_u + forces_b\n        velocities += 0.5 * dt * inv_mass * forces\n\n        # Step A (Half-step position update)\n        positions += 0.5 * dt * velocities\n\n        # Step O (Thermostat and randomization)\n        random_force = np.random.normal(size=(dim,))\n        velocities = c1 * velocities + c3 * inv_mass_sqrt * random_force\n\n        # Step A (Second half-step position update)\n        positions += 0.5 * dt * velocities\n\n        # Step B (Second half-step momentum update)\n        forces_u = force_function_u(positions)\n        forces_b = force_function_b(positions)\n        forces = forces_u + forces_b\n        velocities += 0.5 * dt * inv_mass * forces\n\n    return positions, velocities, forces_u, forces_b\n</code></pre>"},{"location":"reference/utils/#GADES.utils.get_hessian_fdiff","title":"get_hessian_fdiff","text":"<pre><code>get_hessian_fdiff(func, x0, epsilon=1e-06)\n</code></pre> <p>Compute the Hessian matrix of a scalar function using finite differences.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The scalar function f(x) whose Hessian is to be computed.</p> required <code>x0</code> <code>ndarray</code> <p>The point at which the Hessian is evaluated.</p> required <code>epsilon</code> <code>float</code> <p>Small step size for finite difference approximation.</p> <code>1e-06</code> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>The Hessian matrix of f at x0.</p> Source code in <code>GADES/utils.py</code> <pre><code>def get_hessian_fdiff(func: Callable, x0: np.ndarray, epsilon:Optional[float]=1e-6) -&gt; np.ndarray:\n    \"\"\"\n    Compute the Hessian matrix of a scalar function using finite differences.\n\n    Parameters:\n        func (callable): The scalar function f(x) whose Hessian is to be computed.\n        x0 (ndarray): The point at which the Hessian is evaluated.\n        epsilon (float): Small step size for finite difference approximation.\n\n    Returns:\n        ndarray: The Hessian matrix of f at x0.\n    \"\"\"\n    n = len(x0)\n    hessian_matrix = np.zeros((n, n))\n    f1 = approx_fprime(x0, func, epsilon)  # Gradient at x0\n\n    for i in range(n):\n        x_i = x0.copy()\n        x_i[i] += epsilon  # Perturb along dimension i\n        f2 = approx_fprime(x_i, func, epsilon)  # Gradient after perturbation\n        hessian_matrix[:, i] = (f2 - f1) / epsilon  # Second derivative approximation\n\n    return hessian_matrix\n</code></pre>"},{"location":"reference/utils/#GADES.utils.compute_hessian_force_fd_block_parallel","title":"compute_hessian_force_fd_block_parallel","text":"<pre><code>compute_hessian_force_fd_block_parallel(system, positions, atom_indices, epsilon=0.0001, n_jobs=-1, platform_name='CPU')\n</code></pre> <p>Compute the Hessian block for a subset of atoms via finite-difference forces.</p> <p>This function builds the Hessian matrix (second derivatives of the potential energy with respect to Cartesian coordinates) for a selected set of atoms. The calculation perturbs each coordinate by a small displacement and computes the corresponding force differences in parallel. This is the parallel version of <code>compute_hessian_force_fd_block_serial</code>. The performance gain of the parallel version is minimal for systems with &lt;10000 biased particles. Because of <code>joblib</code> overhead, this method is in fact slower than the serial version for small systems.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>The OpenMM system object defining particles, interactions, and forces.</p> required <code>positions</code> <code>Quantity</code> <p>Atomic positions with shape <code>(N, 3)</code>, in units of nanometers.</p> required <code>atom_indices</code> <code>Sequence[int] or None</code> <p>Indices of atoms to include in the Hessian block. If None, all atoms are included.</p> required <code>epsilon</code> <code>float</code> <p>Finite-difference displacement step size (in nanometers). Default is <code>1e-4</code>.</p> <code>0.0001</code> <code>n_jobs</code> <code>int</code> <p>Number of parallel workers for finite-difference force evaluations. Default is <code>-1</code> (use all available cores).</p> <code>-1</code> <code>platform_name</code> <code>str</code> <p>OpenMM platform to use for evaluations (e.g., <code>\"CPU\"</code>, <code>\"CUDA\"</code>). Default is <code>\"CPU\"</code>.</p> <code>'CPU'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A symmetric Hessian block matrix of shape <code>(3M, 3M)</code>, where <code>M</code> is the number of atoms in <code>atom_indices</code>. Units are kJ/(mol\u00b7nm\u00b2).</p> Notes <ul> <li>The Hessian is computed column by column using finite-difference forces:   <pre><code>H_ij = \u2202\u00b2V / (\u2202x_i \u2202x_j)\n</code></pre></li> <li>Parallelization is handled with <code>joblib.Parallel</code>.</li> <li>The final matrix is symmetrized to mitigate finite-difference noise.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hess_block = compute_hessian_force_fd_block_parallel(\n...     system, positions, atom_indices=[0, 1, 2], epsilon=1e-4, n_jobs=4\n... )\n&gt;&gt;&gt; hess_block.shape\n(9, 9)\n</code></pre> Source code in <code>GADES/utils.py</code> <pre><code>def compute_hessian_force_fd_block_parallel(system: openmm.System,\n                                            positions: openmm.unit.Quantity,\n                                            atom_indices: Sequence[int], \n                                            epsilon:Optional[float]=1e-4, \n                                            n_jobs:Optional[int]=-1, \n                                            platform_name:Optional[str]='CPU') -&gt; np.ndarray:\n    \"\"\"\n    Compute the Hessian block for a subset of atoms via finite-difference forces.\n\n    This function builds the Hessian matrix (second derivatives of the potential\n    energy with respect to Cartesian coordinates) for a selected set of atoms.\n    The calculation perturbs each coordinate by a small displacement and computes\n    the corresponding force differences in parallel. This is the parallel version\n    of `compute_hessian_force_fd_block_serial`. The performance gain of the parallel\n    version is minimal for systems with &lt;10000 biased particles. Because of `joblib`\n    overhead, this method is in fact __slower__ than the serial version for small\n    systems.\n\n    Args:\n        system (openmm.System):\n            The OpenMM system object defining particles, interactions, and forces.\n        positions (openmm.unit.Quantity):\n            Atomic positions with shape `(N, 3)`, in units of nanometers.\n        atom_indices (Sequence[int] or None):\n            Indices of atoms to include in the Hessian block. If None, all atoms\n            are included.\n        epsilon (float, optional):\n            Finite-difference displacement step size (in nanometers).\n            Default is `1e-4`.\n        n_jobs (int, optional):\n            Number of parallel workers for finite-difference force evaluations.\n            Default is `-1` (use all available cores).\n        platform_name (str, optional):\n            OpenMM platform to use for evaluations (e.g., `\"CPU\"`, `\"CUDA\"`).\n            Default is `\"CPU\"`.\n\n    Returns:\n        np.ndarray:\n            A symmetric Hessian block matrix of shape `(3M, 3M)`, where `M` is\n            the number of atoms in `atom_indices`. Units are kJ/(mol\u00b7nm\u00b2).\n\n    Notes:\n        - The Hessian is computed column by column using finite-difference forces:\n          ```\n          H_ij = \u2202\u00b2V / (\u2202x_i \u2202x_j)\n          ```\n        - Parallelization is handled with `joblib.Parallel`.\n        - The final matrix is symmetrized to mitigate finite-difference noise.\n\n    Examples:\n        &gt;&gt;&gt; hess_block = compute_hessian_force_fd_block_parallel(\n        ...     system, positions, atom_indices=[0, 1, 2], epsilon=1e-4, n_jobs=4\n        ... )\n        &gt;&gt;&gt; hess_block.shape\n        (9, 9)\n    \"\"\"\n    n_atoms = len(positions)\n    positions_array = np.asarray(positions.value_in_unit(openmm.unit.nanometer))\n\n    # Map atom indices to coordinate indices\n    if atom_indices is None:\n        atom_indices = np.arange(0, n_atoms)\n\n    coord_indices = []\n    for idx in atom_indices:\n        coord_indices.extend([3 * idx, 3 * idx + 1, 3 * idx + 2])\n    m_dof = len(coord_indices)\n\n    def compute_block_column(j):\n        integrator = openmm.VerletIntegrator(1.0 * openmm.unit.femtoseconds)\n        platform = openmm.Platform.getPlatformByName(platform_name)\n        context = openmm.Context(system, integrator, platform)\n\n        positions = positions_array * openmm.unit.nanometer\n        context.setPositions(positions)\n\n        # Reference forces (full, but we'll slice)\n        f0 = _get_openMM_forces(context, positions)[coord_indices]\n\n        # Perturb along coordinate j\n        perturbed_pos = positions_array.flatten()\n        perturbed_pos[j] += epsilon\n        perturbed_pos = perturbed_pos.reshape((-1, 3)) * openmm.unit.nanometer\n\n        f_perturbed = _get_openMM_forces(context, perturbed_pos)[coord_indices]\n\n        df = (f_perturbed - f0) / epsilon\n\n        del context\n        del integrator\n\n        return j, df\n\n    # Parallel over selected j columns only\n    results = Parallel(n_jobs=n_jobs, backend='loky')(\n        delayed(compute_block_column)(j) for j in coord_indices\n    )\n\n    # Assemble square Hessian block\n    hessian_block = np.zeros((m_dof, m_dof))\n    for col_idx, (j, df) in enumerate(results):\n        hessian_block[:, col_idx] = df\n\n    # Symmetrize block\n    hessian_block = 0.5 * (hessian_block + hessian_block.T)\n\n    return hessian_block\n</code></pre>"},{"location":"reference/utils/#GADES.utils.compute_hessian_force_fd_block_serial","title":"compute_hessian_force_fd_block_serial","text":"<pre><code>compute_hessian_force_fd_block_serial(system, positions, atom_indices, epsilon=0.0001, platform_name='CPU')\n</code></pre> <p>Compute the Hessian block for a subset of atoms via finite-difference forces (serial version).</p> <p>This function constructs the Hessian matrix (second derivatives of the potential energy with respect to Cartesian coordinates) for a selected set of atoms. The calculation perturbs each coordinate one at a time and computes the corresponding force differences, without parallelization. Use this version for system with &lt;10000 biased atoms.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>The OpenMM system object defining particles, interactions, and forces.</p> required <code>positions</code> <code>Quantity</code> <p>Atomic positions with shape <code>(N, 3)</code>, in units of nanometers.</p> required <code>atom_indices</code> <code>Sequence[int] or None</code> <p>Indices of atoms to include in the Hessian block. If None, all atoms are included.</p> required <code>epsilon</code> <code>float</code> <p>Finite-difference displacement step size (in nanometers). Default is <code>1e-4</code>.</p> <code>0.0001</code> <code>platform_name</code> <code>str</code> <p>OpenMM platform to use for evaluations (e.g., <code>\"CPU\"</code>, <code>\"CUDA\"</code>). Default is <code>\"CPU\"</code>.</p> <code>'CPU'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A symmetric Hessian block matrix of shape <code>(3M, 3M)</code>, where <code>M</code> is the number of atoms in <code>atom_indices</code>. Units are kJ/(mol\u00b7nm\u00b2).</p> Notes <ul> <li>The Hessian is computed column by column using finite-difference forces:   <pre><code>H_ij = \u2202\u00b2V / (\u2202x_i \u2202x_j)\n</code></pre></li> <li>This serial implementation is simpler but slower than the parallel   version (<code>compute_hessian_force_fd_block_parallel</code>) for large systems.</li> <li>The final matrix is symmetrized to mitigate finite-difference noise.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hess_block = compute_hessian_force_fd_block_serial(\n...     system, positions, atom_indices=[0, 1], epsilon=1e-4\n... )\n&gt;&gt;&gt; hess_block.shape\n(6, 6)\n</code></pre> Source code in <code>GADES/utils.py</code> <pre><code>def compute_hessian_force_fd_block_serial(system: openmm.System,\n                                          positions: openmm.unit.Quantity,\n                                          atom_indices: Sequence[int], \n                                          epsilon: Optional[float]=1e-4, \n                                          platform_name: Optional[str]='CPU') -&gt; np.ndarray:\n    \"\"\"\n    Compute the Hessian block for a subset of atoms via finite-difference forces (serial version).\n\n    This function constructs the Hessian matrix (second derivatives of the potential\n    energy with respect to Cartesian coordinates) for a selected set of atoms. The\n    calculation perturbs each coordinate one at a time and computes the corresponding\n    force differences, without parallelization. Use this version for system with\n    &lt;10000 biased atoms.\n\n    Args:\n        system (openmm.System):\n            The OpenMM system object defining particles, interactions, and forces.\n        positions (openmm.unit.Quantity):\n            Atomic positions with shape `(N, 3)`, in units of nanometers.\n        atom_indices (Sequence[int] or None):\n            Indices of atoms to include in the Hessian block. If None, all atoms\n            are included.\n        epsilon (float, optional):\n            Finite-difference displacement step size (in nanometers).\n            Default is `1e-4`.\n        platform_name (str, optional):\n            OpenMM platform to use for evaluations (e.g., `\"CPU\"`, `\"CUDA\"`).\n            Default is `\"CPU\"`.\n\n    Returns:\n        np.ndarray:\n            A symmetric Hessian block matrix of shape `(3M, 3M)`, where `M` is\n            the number of atoms in `atom_indices`. Units are kJ/(mol\u00b7nm\u00b2).\n\n    Notes:\n        - The Hessian is computed column by column using finite-difference forces:\n          ```\n          H_ij = \u2202\u00b2V / (\u2202x_i \u2202x_j)\n          ```\n        - This serial implementation is simpler but slower than the parallel\n          version (`compute_hessian_force_fd_block_parallel`) for large systems.\n        - The final matrix is symmetrized to mitigate finite-difference noise.\n\n    Examples:\n        &gt;&gt;&gt; hess_block = compute_hessian_force_fd_block_serial(\n        ...     system, positions, atom_indices=[0, 1], epsilon=1e-4\n        ... )\n        &gt;&gt;&gt; hess_block.shape\n        (6, 6)\n    \"\"\"\n    n_atoms = len(positions)\n    positions_array = positions.value_in_unit(openmm.unit.nanometer)\n    positions_array = np.array(positions_array)  # Convert Vec3 list to numpy\n\n    # Map atom indices to coordinate indices\n    if atom_indices is None:\n        atom_indices = np.arange(0, n_atoms)\n\n    coord_indices = []\n    for idx in atom_indices:\n        coord_indices.extend([3 * idx, 3 * idx + 1, 3 * idx + 2])\n    m_dof = len(coord_indices)\n\n    # Prepare Hessian block\n    hessian_block = np.zeros((m_dof, m_dof))\n\n    # Create context (reuse for all columns)\n    integrator = openmm.VerletIntegrator(1.0 * openmm.unit.femtoseconds)\n    platform = openmm.Platform.getPlatformByName(platform_name)\n    context = openmm.Context(system, integrator, platform)\n\n    # Reference forces on selected coordinates\n    positions_nm = positions_array * openmm.unit.nanometer\n    f0 = _get_openMM_forces(context, positions_nm)[coord_indices]\n\n    # Loop over selected perturbations\n    for col_idx, j in enumerate(coord_indices):\n        perturbed_pos = positions_array.flatten()\n        perturbed_pos[j] += epsilon\n        perturbed_pos = perturbed_pos.reshape((-1, 3)) * openmm.unit.nanometer\n\n        f_perturbed = _get_openMM_forces(context, perturbed_pos)[coord_indices]\n\n        df = (f_perturbed - f0) / epsilon\n        hessian_block[:, col_idx] = df\n\n    # Symmetrize\n    hessian_block = 0.5 * (hessian_block + hessian_block.T)\n\n    # Cleanup\n    del context\n    del integrator\n\n    return hessian_block\n</code></pre>"},{"location":"reference/utils/#GADES.utils.compute_hessian_force_fd_richardson","title":"compute_hessian_force_fd_richardson","text":"<pre><code>compute_hessian_force_fd_richardson(system, positions, atom_indices, epsilon=0.0001, platform_name='CPU', factors=None)\n</code></pre> <p>Compute the Hessian block for a subset of atoms using Richardson-extrapolated finite differences.</p> <p>This method estimates second derivatives of the potential energy by recursively applying Richardson extrapolation to finite-difference force calculations at multiple step sizes. This improves accuracy compared to a single-step finite-difference scheme. This is the go-to method for calculating numerical Hessian for GADES. Using the Richardson extrapolation drastically reduces the depency of accuracy on step size and prevents numerical error.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>The OpenMM system object defining particles, interactions, and forces.</p> required <code>positions</code> <code>Quantity</code> <p>Atomic positions with shape <code>(N, 3)</code>, in units of nanometers.</p> required <code>atom_indices</code> <code>Sequence[int] or None</code> <p>Indices of atoms to include in the Hessian block. If None, all atoms are included.</p> required <code>epsilon</code> <code>float</code> <p>Base finite-difference displacement step size (in nanometers). Default is <code>1e-4</code>.</p> <code>0.0001</code> <code>platform_name</code> <code>str</code> <p>OpenMM platform to use for evaluations (e.g., <code>\"CPU\"</code>, <code>\"CUDA\"</code>). Default is <code>\"CPU\"</code>.</p> <code>'CPU'</code> <code>factors</code> <code>Sequence[float]</code> <p>Decreasing list of scaling factors for step sizes, applied to <code>epsilon</code>. Must be strictly decreasing (e.g., <code>[1.0, 0.5, 0.25]</code>). Default is <code>[1.0, 0.5, 0.25]</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A symmetric Hessian block matrix of shape <code>(3M, 3M)</code>, where <code>M</code> is the number of atoms in <code>atom_indices</code>. Units are kJ/(mol\u00b7nm\u00b2).</p> Notes <ul> <li>The Hessian is computed column by column. For each perturbed coordinate,   force differences are evaluated at multiple step sizes and combined via   Richardson extrapolation:   <pre><code>R(k, i) = (r * R(k-1, i+1) - R(k-1, i)) / (r - 1)\n</code></pre>   where <code>r = h_i / h_{i+k}</code> is the ratio of step sizes.</li> <li>Using more factors generally improves accuracy, but increases cost.</li> <li>The final Hessian is symmetrized to reduce numerical noise.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hess_block = compute_hessian_force_fd_richardson(\n...     system, positions, atom_indices=[0, 1],\n...     epsilon=1e-4, factors=[1.0, 0.5, 0.25]\n... )\n&gt;&gt;&gt; hess_block.shape\n(6, 6)\n</code></pre> Source code in <code>GADES/utils.py</code> <pre><code>def compute_hessian_force_fd_richardson(system: openmm.System, \n                                        positions: openmm.unit.Quantity, \n                                        atom_indices: Sequence[int], \n                                        epsilon: Optional[float]=1e-4, \n                                        platform_name: Optional[str]='CPU', \n                                        factors: Optional[Sequence[float]]=None) -&gt; np.ndarray:\n    \"\"\"\n    Compute the Hessian block for a subset of atoms using Richardson-extrapolated\n    finite differences.\n\n    This method estimates second derivatives of the potential energy by\n    recursively applying Richardson extrapolation to finite-difference\n    force calculations at multiple step sizes. This improves accuracy\n    compared to a single-step finite-difference scheme. This is the go-to method\n    for calculating numerical Hessian for GADES. Using the Richardson extrapolation\n    drastically reduces the depency of accuracy on step size and prevents numerical\n    error.\n\n    Args:\n        system (openmm.System):\n            The OpenMM system object defining particles, interactions, and forces.\n        positions (openmm.unit.Quantity):\n            Atomic positions with shape `(N, 3)`, in units of nanometers.\n        atom_indices (Sequence[int] or None):\n            Indices of atoms to include in the Hessian block. If None, all atoms\n            are included.\n        epsilon (float, optional):\n            Base finite-difference displacement step size (in nanometers).\n            Default is `1e-4`.\n        platform_name (str, optional):\n            OpenMM platform to use for evaluations (e.g., `\"CPU\"`, `\"CUDA\"`).\n            Default is `\"CPU\"`.\n        factors (Sequence[float], optional):\n            Decreasing list of scaling factors for step sizes, applied to `epsilon`.\n            Must be strictly decreasing (e.g., `[1.0, 0.5, 0.25]`).\n            Default is `[1.0, 0.5, 0.25]`.\n\n    Returns:\n        np.ndarray:\n            A symmetric Hessian block matrix of shape `(3M, 3M)`, where `M` is\n            the number of atoms in `atom_indices`. Units are kJ/(mol\u00b7nm\u00b2).\n\n    Notes:\n        - The Hessian is computed column by column. For each perturbed coordinate,\n          force differences are evaluated at multiple step sizes and combined via\n          Richardson extrapolation:\n          ```\n          R(k, i) = (r * R(k-1, i+1) - R(k-1, i)) / (r - 1)\n          ```\n          where `r = h_i / h_{i+k}` is the ratio of step sizes.\n        - Using more factors generally improves accuracy, but increases cost.\n        - The final Hessian is symmetrized to reduce numerical noise.\n\n    Examples:\n        &gt;&gt;&gt; hess_block = compute_hessian_force_fd_richardson(\n        ...     system, positions, atom_indices=[0, 1],\n        ...     epsilon=1e-4, factors=[1.0, 0.5, 0.25]\n        ... )\n        &gt;&gt;&gt; hess_block.shape\n        (6, 6)\n    \"\"\"\n\n    if factors is None:\n        factors = [1.0, 0.5, 0.25]  # Default: up to third order\n\n    n_atoms = len(positions)\n    positions_array = positions.value_in_unit(openmm.unit.nanometer)\n    positions_array = np.array(positions_array)\n\n    if atom_indices is None:\n        atom_indices = np.arange(0, n_atoms)\n\n    coord_indices = []\n    for idx in atom_indices:\n        coord_indices.extend([3 * idx, 3 * idx + 1, 3 * idx + 2])\n    m_dof = len(coord_indices)\n\n    hessian_block = np.zeros((m_dof, m_dof))\n\n    # Create context\n    integrator = openmm.VerletIntegrator(1.0 * openmm.unit.femtoseconds)\n    platform = openmm.Platform.getPlatformByName(platform_name)\n    context = openmm.Context(system, integrator, platform)\n\n    # Baseline force\n    f0 = _get_openMM_forces(context, positions_array * openmm.unit.nanometer)[coord_indices]\n\n    for col_idx, j in enumerate(coord_indices):\n        # First, compute all finite-difference derivatives\n        D = []\n        for factor in factors:\n            perturbed_pos = positions_array.copy().flatten()\n            perturbed_pos[j] += factor * epsilon\n            perturbed_pos = perturbed_pos.reshape((-1, 3)) * openmm.unit.nanometer\n            f = _get_openMM_forces(context, perturbed_pos)[coord_indices]\n            d = (f - f0) / (factor * epsilon)\n            D.append(d)\n\n        # Build Richardson tableau\n        R = [D]\n        for k in range(1, len(factors)):\n            prev = R[-1]\n            new = []\n            for i in range(len(prev) - 1):\n                r = (factors[i] / factors[i + k]) ** 1  # first-order FD\n                Rij = (r * prev[i + 1] - prev[i]) / (r - 1)\n                new.append(Rij)\n            R.append(new)\n\n        # Take the most extrapolated value\n        hessian_block[:, col_idx] = R[-1][0]\n\n    # Symmetrize\n    hessian_block = 0.5 * (hessian_block + hessian_block.T)\n\n    del context, integrator\n    return hessian_block\n</code></pre>"},{"location":"reference/utils/#GADES.utils.clamp_force_magnitudes","title":"clamp_force_magnitudes","text":"<pre><code>clamp_force_magnitudes(forces_flat, max_force)\n</code></pre> <p>Clamp the magnitudes of 3D force vectors in a flattened array.</p> <p>This function rescales each 3D force vector so that the magnitude of the bias force on each particle does not exceed <code>max_force</code>. The input is a flattened array where each consecutive triplet of values corresponds to one <code>(fx, fy, fz)</code> vector.</p> <p>Parameters:</p> Name Type Description Default <code>forces_flat</code> <code>ndarray</code> <p>Flattened array of shape <code>(3 * N,)</code>, where <code>N</code> is the number of force vectors. Each consecutive triplet represents a 3D force.</p> required <code>max_force</code> <code>float</code> <p>Maximum allowed magnitude for each force vector. Forces with smaller magnitudes are unchanged.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Flattened array of the same shape as <code>forces_flat</code>, where each 3D force vector has magnitude \u2264 <code>max_force</code>.</p> Notes <ul> <li>Zero-length vectors remain unchanged.</li> <li>The scaling is applied independently to each force vector.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; forces = np.array([3.0, 4.0, 0.0, 0.0, 0.0, 10.0])  # two vectors\n&gt;&gt;&gt; clamped = clamp_force_magnitudes(forces, max_force=5.0)\n&gt;&gt;&gt; clamped\narray([3., 4., 0., 0., 0., 5.])\n</code></pre> Source code in <code>GADES/utils.py</code> <pre><code>def clamp_force_magnitudes(forces_flat: np.ndarray, max_force: float) -&gt; np.ndarray:\n    \"\"\"\n    Clamp the magnitudes of 3D force vectors in a flattened array.\n\n    This function rescales each 3D force vector so that the magnitude of the bias\n    force on each particle does not exceed `max_force`. The input is a flattened\n    array where each consecutive triplet of values corresponds to one `(fx, fy, fz)` vector.\n\n    Args:\n        forces_flat (np.ndarray):\n            Flattened array of shape `(3 * N,)`, where `N` is the number of\n            force vectors. Each consecutive triplet represents a 3D force.\n        max_force (float):\n            Maximum allowed magnitude for each force vector. Forces with\n            smaller magnitudes are unchanged.\n\n    Returns:\n        np.ndarray:\n            Flattened array of the same shape as `forces_flat`, where each\n            3D force vector has magnitude \u2264 `max_force`.\n\n    Notes:\n        - Zero-length vectors remain unchanged.\n        - The scaling is applied independently to each force vector.\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; forces = np.array([3.0, 4.0, 0.0, 0.0, 0.0, 10.0])  # two vectors\n        &gt;&gt;&gt; clamped = clamp_force_magnitudes(forces, max_force=5.0)\n        &gt;&gt;&gt; clamped\n        array([3., 4., 0., 0., 0., 5.])\n    \"\"\"\n    forces = forces_flat.reshape(-1, 3)\n    magnitudes = np.linalg.norm(forces, axis=1)\n    scale = np.minimum(1, np.where(magnitudes != 0, max_force / magnitudes, 1))\n    forces_clamped = forces * scale[:, np.newaxis]\n    return forces_clamped.flatten()\n</code></pre>"}]}